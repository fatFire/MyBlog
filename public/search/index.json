[{"content":"最近看一个仓库的源码时，看到下面addValue1中的“奇怪”写法。我的第一反应是这和addValue2的写法有什么区别吗？slice底层是对数组的操作，为什么还需要再多套一个slice的指针呢？\nfunc addValue1(list *[]int) { *list = append(*list, 1, 2, 3, 4) } func addValue2(list []int) { list = append(list, 1, 2, 3, 4) } 从写法上来说，肯定有区别，形参一个是切片（指针），一个是切片的指针（指针的指针）。\n那么这两种写法从功能上有什么区别吗？先来看看slice扩容的情况：\nfunc main() { s1 := make([]int, 0, 1) s2 := make([]int, 0, 1) addValue1(\u0026amp;s1) addValue2(s2) fmt.Printf(\u0026#34;s1: %v\\n\u0026#34;, s1) fmt.Printf(\u0026#34;s2: %v\\n\u0026#34;, s2) } func addValue1(list *[]int) { *list = append(*list, 1, 2, 3, 4) } func addValue2(list []int) { list = append(list, 1, 2, 3, 4) } 输出结果：\ns1: [1 2 3 4] s2: [] 对于s2来说，addValue中append导致数组扩容，内部开辟新的数组，然而s2还是指向原来的旧数组。所以s2底层的数组没有变化。\n再来看看数组没扩容的情况，s2是否能正确获得添加新元素后的数组呢？\nfunc main() { s1 := make([]int, 0, 10) s2 := make([]int, 0, 10) fmt.Printf(\u0026#34;%p\\n\u0026#34;, s2) addValue1(\u0026amp;s1) addValue2(s2) fmt.Printf(\u0026#34;s1: %v\\n\u0026#34;, s1) fmt.Printf(\u0026#34;s2: %v\\n\u0026#34;, s2) } func addValue1(list *[]int) { *list = append(*list, 1, 2, 3, 4) } func addValue2(list []int) { list = append(list, 1, 2, 3, 4) } 最终的输出：\ns1: [1 2 3 4] s2: [] 这里我们对s1和s2都初始化了长度为0容量为10的切片，并且addValue函数都是添加了4个元素，并不会扩容，那为什么s1，s2在addValue后打印出的值不同呢？\n我们可以看看 s2[:4] 输出什么\nfunc main() { s1 := make([]int, 0, 10) s2 := make([]int, 0, 10) addValue1(\u0026amp;s1) addValue2(s2) fmt.Printf(\u0026#34;s1: %v\\n\u0026#34;, s1) fmt.Printf(\u0026#34;s2: %v\\n\u0026#34;, s2) fmt.Printf(\u0026#34;s2[0:4]: %v\\n\u0026#34;, s2[:4]) } func addValue1(list *[]int) { *list = append(*list, 1, 2, 3, 4) } func addValue2(list []int) { list = append(list, 1, 2, 3, 4) } 输出结果：\ns1: [1 2 3 4] s2: [] s2[0:4]: [1 2 3 4] 可以看到s2的底层数组是成功添加值了的。\n实际上，s2的可视范围还受到len的限制，因为go的函数传参始终是值传递，s2的len始终为0，所以看不到底层数组的变化。如下图所示\n函数调用是值传递，函数内部s2’ 是对s2的拷贝，所以函数内部的改动针对s2’，和s2无关。同样append函数之后返回一个新的s2’’，这也是为什么append的返回值必须接收。\n综上两种情况：slice扩容与不扩容，都使得外部变量s2不会感知到底层数组的变化，而s1却可以。这就是切片的指针的作用。如下图：\n调用addValue(\u0026amp;s1)时，取s1的地址，addValue函数内部s1’ 保存的值是s1的地址。\n调用*s1' = append(*s1', 1,2,3,4)时，append会返回一个新切片，这个新切片保存在s1'指向的内存中，即s1的内存中。\n","date":"2022-02-13T11:14:54+08:00","permalink":"http://example.org/%E5%88%87%E7%89%87%E7%9A%84%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8/","title":"切片的指针的作用"},{"content":"结构体实现接口 一个实例只要实现了一个接口中的全部方法，那么就实现了这个接口。之后，我们就可以利用多态的概念，调用实例实现的接口方法。\n接口体实现变量有两种方式：值接收者和指针接收者\n我们有一个 Mover 接口和一个 dog 结构体\ntype Mover interface { move() } ​ type dog struct {} 值接收者实现接口 func (d dog) move() { fmt.Println(\u0026#34;狗会动\u0026#34;) } 此时实现接口的是dog类型：\nfunc main() { var x Mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // x可以接收dog类型 var fugui = \u0026amp;dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 x.move() } 从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针fugui内部会自动求值*fugui。\n指针接收者实现接口 同样的代码我们再来测试一下使用指针接收者有什么区别：\nfunc (d *dog) move() { fmt.Println(\u0026#34;狗会动\u0026#34;) } func main() { var x Mover var wangcai = dog{} // 旺财是dog类型 x = wangcai // error: x不可以接收dog类型 var fugui = \u0026amp;dog{} // 富贵是*dog类型 x = fugui // x可以接收*dog类型 } 此时实现Mover接口的是*dog类型，所以不能给x传入dog类型的wangcai，此时x只能存储*dog类型的值。\n","date":"2022-02-11T11:14:54+08:00","permalink":"http://example.org/%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82/","title":"指针与结构体的一个细节"},{"content":"问题背景 在 go 中，对于变量声明，即使没有显示的赋初始值，go 也默认给变量赋值，具体的值取决于不同类型对应的零值。本质是 go 中的变量在创建时即分配内存，并且在内存中分配了对应类型的零值。\n零值 基本类型 var a int var b bool var s string fmt.Printf(\u0026#34;%v\u0026#34;, a) // 0 fmt.Printf(\u0026#34;%v\u0026#34;, b) // false fmt.Printf(\u0026#34;%v\u0026#34;, s) // \u0026#34;\u0026#34; 复合类型 var a [4]int var b []int var m map[string]int var p *int var f func() var person Person var c chan int type Person struct { Name string age int } fmt.Printf(\u0026#34;%v\\n\u0026#34;, a) // [0 0 0 0] fmt.Printf(\u0026#34;%v\\n\u0026#34;, b) // [] fmt.Printf(\u0026#34;%v\\n\u0026#34;, m) // map[] fmt.Printf(\u0026#34;%v\\n\u0026#34;, p) // \u0026lt;nil\u0026gt; fmt.Printf(\u0026#34;%v\\n\u0026#34;, f) // \u0026lt;nil\u0026gt; fmt.Printf(\u0026#34;%v\\n\u0026#34;, person) \u0026lt;\u0026#34;\u0026#34;0\u0026gt; fmt.Printf(\u0026#34;%v\\n\u0026#34;, c) // \u0026lt;nil\u0026gt; 总结    Type Zero Value     Integer 0   Floating point 0.0   Boolean false   String “”   Array: [4]int [0 0 0 0]   struct {field: }   Pointer nil   Interface nil   Slice nil   Map nil   Channel nil   Function nil    如何进行空值判断 基本类型 var a *int var b *bool var s *string if a == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;a == 0\u0026#34;) } if b == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;b == nil\u0026#34;) } if s == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;s == nil\u0026#34;) } 复合类型 var a *[4]int var b []int var m map[string]int var p *int var f func() var person *Person var c chan int type Person struct { Name string age int } if a == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;b == nil\u0026#34;) } if b == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;b == nil\u0026#34;) } if m == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;m == nil\u0026#34;) } if p == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;p == nil\u0026#34;) } if f == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;f == nil\u0026#34;) } if person == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;person == nil\u0026#34;) } if c == nil { fmt.Println(\u0026#34;空值判断\u0026#34;, \u0026#34;c == nil\u0026#34;) } 总结：\n  对于值类型，判断空值只能使用值类型的指针变量。因为你无法根据零值判空，因为零值既有可能是程序员赋值，也有可能是初始化赋值。\n  对于数组，var a [4]int。默认创建并初始化，可以直接赋值 a[0] = 1。\n  对于 结构体。它是值类型。默认创建并初始化，内部field初始化成对应类型的空值。\n    对于引用类型，判断空值利用 类型变量 == nil\n  对于 slice 和 map，创建时没有初始化，赋值之前必须初始化。\nvar s []int var m map[string]int s[0] = 1 // panic m[\u0026#34;0\u0026#34;] = 1 // panic  s = make([]int, 4) m = make(map[string]int) s[0] = 1 m[\u0026#34;0\u0026#34;] = 1     区别零值和空值 在变量初始化时，go 自动赋予变量零值(0, false, “”)。\n我们来看一个例子体会零值和空值的区别。\n按需更新，这里指的是接口设计时，规定传来的字段一定是要更新的字段，不需要更新的字段就不要出现。举个例子：\n// PUT /score { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;张三\u0026#34;, \u0026#34;score\u0026#34;: 100, \u0026#34;create_time\u0026#34;: \u0026#34;2021-12-12\u0026#34; } 通过以上json，我们创建一条数据，这时该如何设计更新接口？\n// POST /score {\t\u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;不对，我叫李四\u0026#34;, \u0026#34;score\u0026#34;: 0, \u0026#34;create_time\u0026#34;: \u0026#34;\u0026#34; } 如上，假如规定零值字段不更新，只有非零值的字段参与更新。那么，如果用户真的想把score字段更新为0怎么办，实际上，零值和空值就产生了歧义。\n// POST /score { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;我叫李四\u0026#34; } 所以为了避免歧义，我们规定不更新的字段禁止出现在json中。同样的，在json转为go中的结构体时，我们也只能通过指针来接收：\ntype UpdateScore struct{ Id int Name *string Score *int CreateTime *string } ","date":"2022-02-09T11:14:54+08:00","permalink":"http://example.org/go%E7%9A%84%E9%9B%B6%E5%80%BC%E4%B8%8E%E7%A9%BA%E5%80%BC%E9%97%AE%E9%A2%98/","title":"Go的零值与空值问题"}]